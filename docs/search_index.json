[["index.html", "DISSERTATION NOTES Preface", " DISSERTATION NOTES Erol Biçer 2022-12-19 Preface My notes to be used in my dissertation. "],["icte-derivation.html", "ICTE Derivation Source term due to Bubble Expansion, \\(R\\) Coalescence due to Wake Entrainment, \\(R_{WE}\\) Coalescence due to Random Collisions, \\(R_{RC}\\) Break-up due to Turbulent Impact, \\(R_{TI}\\)", " ICTE Derivation The derivation of the Interfacial Area Transport Equation (IATE) started with [1] in 1975 when he published the two-fluid model. Nearly, two decades later, [2] published the foundation of IATE. The model is also adopted by OpenFOAM which is included in the Foam class of diameter models. IATE is a transport equation that solves for the Interfacial Area Concentration (IAC), \\(a_i\\), however, OpenFOAM does not solve for IAC instead it solves for interfacial area curvature, \\(\\kappa\\), to avoid stability issues as indicated in the source code. It is also mentioned that the model is based on the work of [3] in which the IATE is given as shown in equation (1) assuming no phase change. \\[\\begin{equation} \\frac{\\partial a_i}{\\partial t}+\\nabla \\cdot\\left(a_i \\boldsymbol{v}_{\\mathrm{i}}\\right) = \\frac{2}{3}\\left(\\frac{a_i}{\\alpha}\\right)\\left(\\frac{\\partial \\alpha}{\\partial t}+\\nabla \\cdot \\alpha \\boldsymbol{v}_{\\mathrm{g}}\\right) +\\frac{1}{3 \\psi}\\left(\\frac{\\alpha}{a_i}\\right)^2 \\sum_j R_j \\tag{1} \\end{equation}\\] After adding the developed source and sink terms the expanded form of the IATE can be obtained as given in equation (2). \\[\\begin{equation} \\begin{split} \\frac{\\partial a_i}{\\partial t}+\\nabla \\cdot\\left(a_i v_i\\right) &amp;=\\frac{2}{3}\\left(\\frac{a_i}{\\alpha}\\right)\\left(\\frac{\\partial \\alpha}{\\partial t}+\\nabla \\cdot \\alpha v_g\\right) \\\\ &amp;+\\frac{1}{3 \\psi}\\left(\\frac{\\alpha}{a_i}\\right)^2\\left[C_{TI}\\left(\\frac{n u_t}{D_b}\\right)\\sqrt{1-\\frac{W e_{c r}}{W e}} \\exp \\left(-\\frac{W e_{cr}}{W e}\\right) \\right] \\\\ &amp;-\\frac{1}{3 \\psi}\\left(\\frac{\\alpha}{a_i}\\right)^2\\left[C_{R C}\\frac{n^2 u_t D_b^2}{\\alpha_{max}^{1 / 3}\\left(\\alpha_{\\max }^{1 / 3}-\\alpha^{1 / 3}\\right)}\\left[1-\\exp \\left(-C \\frac{\\alpha_{max}^{1 / 3} \\alpha^{1 / 3}}{\\alpha_{\\max }^{1 / 3}-\\alpha^{1 / 3}}\\right)\\right]\\right] \\\\ &amp;-\\frac{1}{3 \\psi}\\left(\\frac{\\alpha}{a_i}\\right)^2\\left[C_{W E} C_D^{1 / 3} n^2 u_r D_b^2\\right] \\end{split} \\tag{2} \\end{equation}\\] It is intended the convert IATE to Interfacial Curvature Transport Equation (ICTE) by using the main relationship between the \\(\\kappa\\) and \\(a_i\\) which is given in (3). It should also be noted that it is also possible to estimate the Sauter mean diameter, \\(d_{sm}\\), through \\(\\kappa\\) as shown in equation (4). \\[\\begin{equation} \\kappa = \\frac{a_i}{\\alpha} \\tag{3} \\end{equation}\\] \\[\\begin{equation} D_b \\equiv d_{sm}= 6\\frac{\\alpha}{a_i} \\quad \\longrightarrow \\quad D_b \\equiv d_{sm} = \\frac{6}{\\kappa} \\tag{4} \\end{equation}\\] In order to derive ICTE, all the \\(a_i\\) terms in equation @ref(eq:1} should be replaced by \\(a_i=\\alpha\\kappa\\). In addition, both interfacial are concentration velocity, \\(v_i\\), and the gas velocity \\(v_g\\) should be replaced by \\(\\mathbf{u}\\) the volume flux at the cell faces. The methodology provided by [4] is followed here to obtain ICTE. Substitute \\(a_i=\\alpha\\kappa\\): \\[\\begin{equation} \\frac{\\partial \\color{red}{\\alpha\\kappa}}{\\partial t}+\\nabla \\cdot\\left({\\color{red}{\\alpha\\kappa}}\\mathbf{u}\\right) = \\frac{2}{3}\\left(\\frac{{\\color{red}{\\alpha\\kappa}}}{\\alpha}\\right)\\left(\\frac{\\partial \\alpha}{\\partial t}+\\nabla \\cdot \\alpha \\mathbf{u}\\right) +\\frac{1}{3 \\psi}\\left(\\frac{\\alpha}{{\\color{red}{\\alpha\\kappa}}}\\right)^2 \\sum_j R_j \\tag{5} \\end{equation}\\] Apply the product rule for the first and second terms: \\[\\begin{equation} \\alpha\\frac{\\partial \\kappa}{\\partial t}+\\kappa\\frac{\\partial \\alpha}{\\partial t} +\\kappa\\nabla \\cdot\\left(\\alpha\\mathbf{u}\\right) +\\alpha\\mathbf{u}\\cdot\\nabla \\kappa = \\frac{2}{3}\\kappa\\left(\\frac{\\partial \\alpha}{\\partial t}+\\nabla \\cdot \\alpha \\mathbf{u}\\right) +\\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\sum_j R_j \\tag{6} \\end{equation}\\] Group for \\(\\alpha\\) and \\(\\kappa\\): \\[\\begin{equation} \\alpha\\left[\\frac{\\partial \\kappa}{\\partial t} +\\mathbf{u}\\cdot\\nabla \\kappa\\right] + \\kappa\\left[\\frac{\\partial \\alpha}{\\partial t}+\\nabla \\cdot\\left(\\alpha\\mathbf{u}\\right)\\right] = \\frac{2}{3}\\kappa\\left(\\frac{\\partial \\alpha}{\\partial t}+\\nabla \\cdot \\alpha \\mathbf{u}\\right) +\\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\sum_j R_j \\tag{7} \\end{equation}\\] Looking at equation (7), one can see that the contents of the parentheses in the second and first terms of the LHS and RHS equation are the same. Subtracting these terms from each other lead to equation (8). \\[\\begin{equation} \\alpha\\left[\\frac{\\partial \\kappa}{\\partial t} +\\mathbf{u}\\cdot\\nabla \\kappa\\right] = -\\frac{1}{3}\\kappa\\left(\\frac{\\partial \\alpha}{\\partial t}+\\nabla \\cdot \\alpha \\mathbf{u}\\right) +\\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\sum_j R_j \\tag{8} \\end{equation}\\] Dividing both sides by \\(\\alpha\\) yields to: \\[\\begin{equation} \\frac{\\partial \\kappa}{\\partial t} +\\mathbf{u}\\cdot\\nabla \\kappa = -\\frac{1}{3}\\frac{\\kappa}{\\alpha}\\left(\\frac{\\partial \\alpha}{\\partial t}+\\nabla \\cdot \\alpha \\mathbf{u}\\right) +\\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2\\frac{1}{\\alpha} \\sum_j R_j \\tag{9} \\end{equation}\\] Applying the product rule for the second term on the LHS of the equation leads to the final form of the ICTE as shown in (10). It should also be noted that converting IATE to ICTE does not affect the source and sink terms modeling in theory since none of them is dependent on interfacial area concentration, \\(a_i\\). \\[\\begin{equation} \\frac{\\partial \\kappa}{\\partial t} + \\nabla (\\kappa\\mathbf{u}) - \\kappa\\nabla\\mathbf{u} = -\\frac{1}{3}\\frac{\\kappa}{\\alpha}\\left(\\frac{\\partial \\alpha}{\\partial t}+\\nabla \\cdot \\alpha \\mathbf{u}\\right) +\\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2\\frac{1}{\\alpha} \\sum_j R_j \\tag{10} \\end{equation}\\] The next step is to check whether OpenFOAM implements equation (10) as it is. The source code files of IATE class are located in the diameterModels directory of the multiphaseEulerFoam solver. The IATE.C file is the main source code that constructs the ICTE (kappaiEqn) by constructing an object called IATE which is a member function of the class Foam::diameterModels. The model’s location and directory organization can be seen in the directory tree below. All the included source and sink terms are located under the IATEsources folder with intuitive names. For instance, the turbulent breakup source code files are located in the turbulentBreakUp folder. . ├── \\applications\\solvers\\multiphase\\multiphaseEulerFoam\\phaseSystems\\diameterModels\\IATE:. ├── │ IATE.C ├── │ IATE.H └── └───IATEsources/ ├── ├───dummy ├── │ dummy.C ├── │ dummy.H ├── ├───IATEsource ├── │ IATEsource.C ├── │ IATEsource.H ├── ├───phaseChange ├── │ IATEphaseChange.C ├── │ IATEphaseChange.H ├── ├───randomCoalescence ├── │ IATErandomCoalescence.C ├── │ IATErandomCoalescence.H ├── ├───turbulentBreakUp ├── │ IATEturbulentBreakUp.C ├── │ IATEturbulentBreakUp.H ├── ├───wakeEntrainmentCoalescence ├── │ IATEwakeEntrainmentCoalescence.C ├── │ IATEwakeEntrainmentCoalescence.H └── └───wallBoiling/ IATEwallBoiling.C IATEwallBoiling.H Looking at the main source code in IATE.C, one can see that \\(a_i\\) is calculated as shown in the third line of Snippet #1 which is inconsistent with equation (3). 1 Foam::tmp&lt;Foam::volScalarField&gt; Foam::diameterModels::IATE::a() const 2 { 3 return phase()*kappai_; 4 } Snippet #1: Definition of Interfacial Area Concentration, \\(a_i\\) The ICTE matrix is constructed as shown in Snippet #2 and it corresponds to equation (10). The fourth and fifth lines inside the kappaiEqn() agree with the temporal and convective terms on the LHS of equation (10). The remaining bubble expansion term and the source/sink terms in equation (10) are constructed through R and the fvModels.source() function enables users to implement additional linearized sources as shown in Snippet #2. It should be noted that the == operator in OpenFOAM returns a subtraction of matrices rather than equating them. The construction of R in line 7 of Snippet#2 is introduced in the following sections. 1 // Construct the interfacial curvature equation 2 fvScalarMatrix kappaiEqn 3 ( 4 fvm::ddt(kappai_) + fvm::div(phase().phi(), kappai_) 5 - fvm::Sp(fvc::div(phase().phi()), kappai_) 6 == 7 R 8 + fvModels.source(kappai_) 9 ); Snippet #2: Construction of ICTE Matrix Source term due to Bubble Expansion, \\(R\\) Snippet #3 shows how the scalar matrix R is initialized for the bubble expansion term which is the first term on the RHS of equation (10). Eventually, all the other source and sink terms will be added to R and solved for kappaiEqn as shown in Snippet #2. It can be seen in line 3 of Snippet#3 that the fvm::SuSp function is utilized for the bubble expansion term. fvm::SuSp takes two arguments: the first one is in the lines between 5 to 13 and the second one is kappai_ in line 16 of Snippet #3. We can see that the first term resembles the bubble expansion term except for \\(\\kappa\\) in equation (10). The lines between 11 through 15 account for the phase continuity that should be compensated for. The SuSp is a hybrid source term treatment function that automatically decides on treating the source either implicitly or explicitly. The function selects the implicit treatment and alters the diagonals of the coefficient matrix if the first argument is greater than zero. This comes from considering the diagonal dominance of the coefficient matrix. However, if the first argument is negative the function then multiplies the first argument with the second (i.e. \\(\\kappa\\)) one and modifies the source vector which is the explicit treatment. We can also check the units to see if the given logic is correct. The unit of the first argument in Snippet #3 is \\(\\frac{1}{s}\\) which can be added the coefficient matrix and if it is multiplied with the second argument then the unit becomes \\(\\frac{1}{s}*\\frac{1}{m} = \\frac{1}{ms}\\) which can be added to the source vector. Therefore, the units are consistent. Finally, paying attention to the negative sign in front of the SuSp function in line 4 of Snippet #3, it can be confirmed that the bubble expansion term is implemented consistently with the reference model. 1 fvScalarMatrix R 2 ( 3 -fvm::SuSp 4 ( 5 ((1.0/3.0)/alphaAv) 6 *( 7 ( 8 fvc::ddt(phase()) 9 + fvc::div(phase().alphaPhi()) 10 ) 11 - ( 12 fvc::ddt(phase(), phase().rho()()) 13 + fvc::div(phase().alphaRhoPhi()) 14 )/phase().rho() 15 ), 16 kappai_ 17 ) 18 ); Snippet #3: Initialzing of the Scalar Matrix R After initializing R for the bubble expansion term, a loop iterates over all the sources and adds their contribution to the R matrix by taking the alphaAv and kappai fields as arguments as shown in the fourth line of Snippet 4. Now the ICTE can be solved and the Sauter mean diameter can be updated in the code for the next time step. 1 // Accumulate the run-time selectable sources 2 forAll(sources_, j) 3 { 4 R += sources_[j].R(alphaAv, kappai_); 5 } Snippet #4: Accumulation of ICTE sources and sinks into R() The time rate change and convection changes of \\(\\kappa\\) together with the change of \\(\\kappa\\) due to volume change are consistently codded in OpenFOAM V10 as modeled in equation (10). The only remaining part to check is the source and sink terms which is the last term in equation (10). The reference models of the rates for interfacial area concentration are given in equation @ref(eq:2}. Although the modeling of the rates was not changed when deriving ICTE, it is nevertheless important to verify that they were consistently implemented in OpenFOAM. Three major bubble interaction mechanisms have been considered as source and sink terms. These are bubble break-up due to Turbulent Impact, \\(R_{TI}\\), coalescence due to Random Collisions, \\(R_{RC}\\), and coalescence due to Wake Entrainment, \\(R_{WE}\\). In OpenFOAM, all the calculated source terms are implemented by certain source term treatment functions which are introduced below. Coalescence due to Wake Entrainment, \\(R_{WE}\\) The function to calculate the \\(R_{WE}\\) is given in Snippet #5. It is a sink term since the number of bubbles decreases when it occurs. This can be confirmed by the negative sign in line 8 of Snippet #5. \\(R_{WE}\\) is returned by utilizing the earlier-introduced SuSp() function which takes the matrix diagonal dominance into consideration when treating the source term. When the first argument of the function is positive, an implicit approach is used by adjusting the diagonal coefficients in the matrix, however, when the first argument is negative, an explicit approach is used by modifying the source vector coefficients. It should also be noted that the unit of the return value by the SuSp() function is \\(\\frac{1}{m}\\frac{m}{s}*\\frac{1}{m} = \\frac{1}{ms}\\) which is consistent with the unit of the dilatation term in Snippet #3 and the rest of the terms on the LHS of equation (10). 1 Foam::tmp&lt;Foam::fvScalarMatrix&gt; 2 Foam::diameterModels::IATEsources::wakeEntrainmentCoalescence::R 3 ( 4 const volScalarField&amp; alphai, 5 volScalarField&amp; kappai 6 ) const 7 { 8 return -fvm::SuSp(12*phi()*Cwe_*cbrt(CD())*iate_.a()*Ur(), kappai); 9 } Snippet #5: OpenFOAM Implementation of \\(R_{WE}\\) Comparing Snippet #5 and the corresponding sink terms of equations @ref(eq:2} and (10), one can see that equation (13) must be satisfied where \\(R_{j,REF}\\) is the reference theoretical rates in equation @ref(eq:2} and \\(R_{j,OF}\\) is the rates implemented in OpenFOAM. \\[\\begin{equation} \\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} R_{j,REF} = \\kappa (R_{j,OF}) \\tag{11} \\end{equation}\\] Before comparing the rates, it would be useful to remember some important relationships given in equations @ref(eq:3} and @ref(eq:4} together with (12) where \\(n\\) is the number density and \\(\\psi\\) is the sphericity (shape factor). \\[\\begin{equation} n=\\psi \\frac{a_i^3}{\\alpha^2} \\quad \\text{where;} \\quad \\psi=\\frac{1}{36 \\pi} \\tag{12} \\end{equation}\\] The first comparison can be done for \\(R_{WE}\\) given in Snippet #5. Following the rate comparison criterion in equation (11), one can check whether the implementation was done consistently in OpenFOAM. The derivation in equation (13) proves that the implementation of \\(R_{WE}\\) is consistent with the given reference. \\[\\begin{equation} \\begin{split} \\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} R_{WE,REF} &amp;= \\kappa R_{WE,OF} \\\\ \\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} \\left[C_{W E} C_D^{1 / 3} n^2 u_r D_b^2\\right] &amp;= \\kappa \\left[12\\psi C_{W E} C_D^{1 / 3} a_i u_r\\right] \\\\ \\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} \\left[n^2 D_b^2\\right] &amp;= \\kappa \\left[12\\psi a_i\\right] \\\\ \\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} \\left[\\psi\\frac{a_i^3}{\\alpha^2}6\\frac{\\alpha}{ai}\\right]^2 &amp;= \\kappa \\left[36\\psi^2 a_i\\right] \\\\ \\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} \\left[36\\psi^2\\frac{a_i^4}{\\alpha^2}\\right] &amp;= \\kappa \\left[36\\psi^2 a_i\\right] \\\\ \\left[\\frac{a_i}{\\alpha}\\right]^3 &amp;= \\kappa^3\\\\ \\space \\kappa^3 &amp;= \\kappa^3 \\\\ \\therefore \\space \\kappa &amp;= \\kappa \\\\ \\end{split} \\tag{13} \\end{equation}\\] Coalescence due to Random Collisions, \\(R_{RC}\\) The next one is \\(R_{RC}\\), and Snippet #6 describes how it is implemented in OpenFOAM. The rates of the reference and implemented model are shown in equations (14) and (15), respectively. It can be seen that the implementation of \\(R_{RC}\\) is different than the earlier introduced \\(R_{WE}\\). A local object of R is constructed in lines between 8 and 18 of Snippet #6 with a dimension of \\(\\frac{1}{s}\\) as shown in line 17. The implemented \\(R_{RC}\\), which can be seen in the lines between 33 and 38, has the consistently defined unit of \\(\\frac{1}{s}\\). It can be seen that the source treatment is performed through the Sp() function which performs an implicit source term treatment by modifying the diagonal coefficients of the coefficient matrix. This explains why the defined unit is \\(\\frac{1}{s}\\) because the coefficient matrix is multiplied by the dependent variable (i.e. \\(\\kappa\\)) already which makes the unit \\(\\frac{1}{ms}\\) which is consistent with \\(R_{WE}\\) and the rest of the investigated terms of equation (10) so far. 1 Foam::tmp&lt;Foam::fvScalarMatrix&gt; 2 Foam::diameterModels::IATEsources::randomCoalescence::R 3 ( 4 const volScalarField&amp; alphai, 5 volScalarField&amp; kappai 6 ) const 7 { 8 volScalarField::Internal R 9 ( 10 IOobject 11 ( 12 &quot;randomCoalescence:R&quot;, 13 iate_.phase().time().timeName(), 14 iate_.phase().mesh() 15 ), 16 iate_.phase().mesh(), 17 dimensionedScalar(dimless/dimTime, 0) 18 ); 19 20 const scalar Crc = Crc_.value(); 21 const scalar C = C_.value(); 22 const scalar alphaMax = alphaMax_.value(); 23 const volScalarField Ut(this-&gt;Ut()); 24 const volScalarField&amp; alpha = phase(); 25 const scalar cbrtAlphaMax = cbrt(alphaMax); 26 27 forAll(R, celli) 28 { 29 if (kappai[celli] &gt; 0 &amp;&amp; alpha[celli] &lt; alphaMax - small) 30 { 31 const scalar cbrtAlphaMaxMAlpha = cbrtAlphaMax - cbrt(alpha[celli]); 32 33 R[celli] = 34 12*phi()*kappai[celli]*alpha[celli] 35 *Crc 36 *Ut[celli] 37 *(1 - exp(-C*cbrt(alpha[celli]*alphaMax)/cbrtAlphaMaxMAlpha)) 38 /(cbrtAlphaMax*cbrtAlphaMaxMAlpha); 39 } 40 } 41 42 return -fvm::Sp(R, kappai); 43 } Snippet #6: OpenFOAM Implementation of \\(R_{RC}\\) The rate comparison is given in equation (16) after canceling out the long common terms in equations (14) and (15) for readability. It is also proven that \\(R_{RC}\\) implemented in OpenFOAM is consistent with the reference model. \\[\\begin{equation} \\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} \\left[C_{R C}\\frac{n^2 u_t D_b^2}{\\alpha_{max}^{1 / 3}\\left(\\alpha_{\\max }^{1 / 3}-\\alpha^{1 / 3}\\right)}\\left[1-\\exp \\left(-C \\frac{\\alpha_{max}^{1 / 3} \\alpha^{1 / 3}}{\\alpha_{\\max }^{1 / 3}-\\alpha^{1 / 3}}\\right)\\right]\\right] \\tag{14} \\end{equation}\\] \\[\\begin{equation} \\kappa \\left[12\\psi \\kappa \\alpha C_{RC} u_t\\right]\\left[1-\\exp \\left(-C \\frac{\\alpha_{max}^{1 / 3} \\alpha^{1 / 3}}{\\alpha_{\\max }^{1 / 3}-\\alpha^{1 / 3}}\\right)\\right]\\left[\\frac{1}{\\alpha_{max}^{1 / 3}\\left(\\alpha_{\\max }^{1 / 3}-\\alpha^{1 / 3}\\right)}\\right] \\tag{15} \\end{equation}\\] \\[\\begin{equation} \\begin{split} \\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} R_{RC,REF} &amp;= \\kappa R_{RC,OF} \\\\ \\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} \\left[n^2 D_b^2\\right] &amp;= \\kappa \\left[12\\psi \\kappa \\alpha\\right] \\\\ \\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} \\left[\\psi\\frac{a_i^3}{\\alpha^2}6\\frac{\\alpha}{ai}\\right]^2 &amp;= \\kappa \\left[36\\psi^2 \\kappa \\alpha\\right] \\\\ \\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} \\left[36\\psi^2\\frac{a_i^4}{\\alpha^2}\\right] &amp;= \\kappa \\left[36\\psi^2 \\kappa \\alpha\\right] \\\\ \\left[\\frac{a_i}{\\alpha}\\right]^4 &amp;= \\kappa^4\\\\ \\space \\kappa^4 &amp;= \\kappa^4 \\\\ \\therefore \\space \\kappa &amp;= \\kappa \\\\ \\end{split} \\tag{16} \\end{equation}\\] Break-up due to Turbulent Impact, \\(R_{TI}\\) The implementation of the last and only source term, \\(R_{TI}\\), is given in Snippet #7. The rates of the reference and implemented model are shown in equations (17) and (18), respectively. It can be seen that the implementation of \\(R_{TI}\\) is similar to the earlier introduced \\(R_{RC}\\). However, unlike \\(R_{RC}\\), the defined unit of the local R is \\(\\frac{1}{ms}\\) as can be seen in line 17 of Snippet #7. This is due to the utilization of the Su() function which treats the source term explicitly by modifying the source vector coefficients in the equation. Therefore the returned unit must be \\(\\frac{1}{ms}\\) which can be seen in lines 30 and 31 of Snippet #7. 1 Foam::tmp&lt;Foam::fvScalarMatrix&gt; 2 Foam::diameterModels::IATEsources::turbulentBreakUp::R 3 ( 4 const volScalarField&amp; alphai, 5 volScalarField&amp; kappai 6 ) const 7 { 8 volScalarField::Internal R 9 ( 10 IOobject 11 ( 12 &quot;turbulentBreakUp:R&quot;, 13 iate_.phase().time().timeName(), 14 iate_.phase().mesh() 15 ), 16 iate_.phase().mesh(), 17 dimensionedScalar(kappai.dimensions()/dimTime, 0) 18 ); 19 20 const scalar Cti = Cti_.value(); 21 const scalar WeCr = WeCr_.value(); 22 const volScalarField Ut(this-&gt;Ut()); 23 const volScalarField We(this-&gt;We()); 24 25 forAll(R, celli) 26 { 27 if (We[celli] &gt; WeCr) 28 { 29 R[celli] = 30 (Cti/18)*Ut[celli]*sqr(kappai[celli]) 31 *sqrt(1 - WeCr/We[celli])*exp(-WeCr/We[celli]); 32 } 33 } 34 35 return fvm::Su(R, kappai); 36 } Snippet #7: OpenFOAM Implementation of \\(R_{TI}\\) The rate comparison is given in equation (19) after canceling out the long common terms in equations (17) and (18) for readability. It can be seen in (18) and (19) the source and comparison criterion is different than the previous comparisons because a factor of \\(\\kappa\\) is missing. This is due to the fact that the returned unit from the local R is already \\(\\frac{1}{ms}\\) and the Su() function changes the source term coefficients as it is. Equation (19) reveals that the implemented \\(R_{TI}\\) is consistent with the reference. \\[\\begin{equation} \\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} \\left[C_{TI}\\left(\\frac{n u_t}{D_b}\\right)\\sqrt{1-\\frac{W e_{c r}}{W e}} \\exp \\left(-\\frac{W e_{cr}}{W e}\\right)\\right] \\tag{17} \\end{equation}\\] \\[\\begin{equation} \\frac{1}{18}C_{TI} u_t\\kappa^2\\sqrt{1-\\frac{W e_{c r}}{W e}} \\exp \\left(-\\frac{W e_{cr}}{W e}\\right) \\tag{18} \\end{equation}\\] \\[\\begin{equation} \\begin{split} \\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} R_{TI,REF} &amp;= R_{TI,OF} \\\\ \\frac{1}{3 \\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} \\left[\\frac{n}{D_b}\\right] &amp;= \\frac{\\kappa^2}{18} \\\\ \\frac{1}{\\psi}\\left(\\frac{1}{\\kappa}\\right)^2 \\frac{1}{\\alpha} \\left[\\frac{\\psi\\frac{a_i^3}{\\alpha^2}}{6\\frac{\\alpha}{ai}}\\right] &amp;= \\frac{\\kappa^2}{6} \\\\ \\left(\\frac{1}{\\kappa}\\right)^2 \\left[\\frac{a_i^4}{\\alpha^4}\\right] &amp;= \\kappa^2 \\\\ \\left[\\frac{a_i}{\\alpha}\\right]^4 &amp;= \\kappa^4\\\\ \\space \\kappa^4 &amp;= \\kappa^4 \\\\ \\therefore \\space \\kappa &amp;= \\kappa \\\\ \\end{split} \\tag{19} \\end{equation}\\] The above discussion concludes that the one-group IATE is implemented into OpenFOAM V10 consistently with the theoretical model given in (2). References "],["source-term-treatment.html", "Source Term Treatment Explicit Treatment Su() Implicit Treatment Sp() Hybrid Treatment SuSp()", " Source Term Treatment The partial differential equations are converted into sets of algebraic equations through equation discretization that is usually in the form of equation (1) where \\([A]\\) is the sparse coefficient matrix, \\([x]\\) is the unknown column vector, and \\([b]\\) is the source vector. The coefficients of the algebraic equations are stored in the \\([A]\\) matrix through the fvMatrix template class after the discretization. \\[\\begin{equation} [A][x]=[b] \\tag{1} \\end{equation}\\] Source terms can be specified as Explicit, Implicit, and Implicit/Explicit (Hybrid hereinafter) through Su(), Sp(), and SuSp() functions, respectively, in OpenFOAM. These functions handle the incorporation of the source terms into the coefficient matrices and source term vectors. The Explicit treatment through Su() alters the coefficients in the source vector (i.e. \\([b]\\)) while the Implicit treatment through Sp() modifies only the diagonal coefficients in the coefficient matrix (i.e. \\([A]\\)). The Hybrid treatment automatically selects between the Implicit and Explicit treatment depending on the sign of the coefficients. The Implicit treatment is selected if the coefficients are greater than zero or the Explicit treatment is selected if the coefficients are less than zero. Though this sounds arbitrary, there is a good reason behind it which perhaps can best be explained with an example. Let’s look at the steady one-dimensional heat conduction example given in [5] as given in equation (2) where \\(k\\) is the thermal conductivity, \\(T\\) is the temperature, and \\(S\\) is the rate of heat generation per unit volume. \\[\\begin{equation} \\frac{d}{d x}\\left(k \\frac{d T}{d x}\\right)+S=0 \\tag{2} \\end{equation}\\] The discretization of equation (2) can be done after utilizing the widely used grid-point notation where P is the central node, and E and W are the neighbors. More on the notation can be found at [5]. \\[\\begin{equation} \\begin{aligned} \\left(k \\frac{d T}{d x}\\right)_e-\\left(k \\frac{d T}{d x}\\right)_w+\\int_w^e S d x &amp;=0 \\\\ \\frac{k_e\\left(T_E-T_P\\right)}{(\\delta x)_e}-\\frac{k_w\\left(T_P-T_W\\right)}{(\\delta x)_w}+\\bar{S} \\Delta x &amp;=0 \\\\ \\end{aligned} \\tag{3} \\end{equation}\\] where; \\[\\begin{equation} \\bar{S}=S_C+S_P T_P \\tag{4} \\end{equation}\\] \\(\\bar{S}\\) is the average value of source therm over the control volume which is consisted of a constant \\(S_C\\) and a coefficient \\(S_P\\) of the dependent variable \\(T_P\\). It can be seen that the \\(\\bar{S}\\) is constructed as a linear source which will be discussed more in detail later. The discretized equation (3) can now be written in a more general format as shown in equation (5). \\[\\begin{equation} a_P T_P=a_E T_E+a_W T_W+b \\tag{5} \\end{equation}\\] where; \\[\\begin{equation} \\begin{aligned} a_E &amp;=\\frac{k_e}{(\\delta x)_e} \\\\ a_W &amp;=\\frac{k_w}{(\\delta x)_w} \\\\ a_P &amp;=a_E+a_W - S_P\\Delta x \\\\ b &amp;=S_C\\Delta x \\end{aligned} \\tag{6} \\end{equation}\\] It is known that in practical applications, the source could be dependent or independent of the dependent variable (i.e. \\(T\\)) in the algebraic equation. This is the reason why the source is defined as it is in equation (4). Because the discretized equations are linear, the source term can also only have a linear dependence. However, there could be sources that are nonlinear in certain applications. Therefore, a linearization must be done to be able to incorporate the source terms into the discretized equations. This is done by iterative procedures by splitting the \\(S_C\\) and \\(S_P\\) parts in an intuitive way. However, the details will not be discussed here. What we are trying to understand is how this source term is incorporated into the diagonal coefficient matrix and source vector. The reasoning lay in equation (6). In [5], four basic rules were laid out to best represent the physics by the proposed procedure. Rule number 2 requires all positive coefficients meaning that the neighbors and the center-point coefficients must have the same sign. Rule number 3 is about the source term linearization. According to the rule, only a negative slope linearization is accepted. And the acceptance criterion is that the \\(S_P\\) in equation (4) must be always negative or equal to zero when the source term is linearized. The reasoning can be seen in equation (6) that \\(- S_P\\Delta x\\) is added to the \\(a_P\\) which constructs the diagonal terms of the matrix equation. Considering the diagonal dominance, which basically demands a positive (rule number 2) and large \\(a_P\\), it is possible to get negative values if \\(S_P\\) is positive. Therefore, in order to ensure all positive (and large) diagonal coefficients, \\(S_P\\) must be negative or equal to zero. As for the constant part (\\(S_C\\)) of the source, it can be seen in \\(b\\) in equation (6) that it is added to the source directly as it is. Considering the above explanation, now the source term treatment in OpenFOAM can be explained further. Due to the matrix operations in OpenFOAM, equation (1) is in fact constructed as shown in equation (7) by sending the source term to the left-hand side (LHS). This will be useful later once the individual source treatment functions are introduced. \\[\\begin{equation} [A][x] + [-b] = 0 \\tag{7} \\end{equation}\\] It is now possible to investigate the coded source term treatment functions; Su(), Sp(), and SuSp() more in detail. The source codes and the header files of the functions can be found in the ~\\src\\finiteVolume\\finiteVolume\\fvm directory with the names fvmSup.C and fvmSup.H. It should be noted that these functions can both be utilized for finiteVolumeMethod (fvm::) and finiteVolumeCalculus (fvc::) static functions however the explanation here is based on the fvm:: one. These functions use two arguments, for instance, Su(\\(\\Phi\\),\\(x\\)). The first argument \\(\\Phi\\) is the field variable of the source term and \\(x\\) is the dependent variable of the solved equation. Explicit Treatment Su() The first one to explore is the Explicit treatment through the Su() function in OpenFOAM. Snippet #1 shows how the Su() is implemented. Looking at line 21 of Snippet #1, one can see that su.field() (the first argument in the function, i.e. \\(\\Phi\\)) is subtracted from the fvm.source() matrix which is the \\([-b]\\) in equation (7). This confirms that Su() is implemented in agreement with the theory. 1 template&lt;class Type&gt; 2 Foam::tmp&lt;Foam::fvMatrix&lt;Type&gt;&gt; 3 Foam::fvm::Su 4 ( 5 const DimensionedField&lt;Type, volMesh&gt;&amp; su, 6 const GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; vf 7 ) 8 { 9 const fvMesh&amp; mesh = vf.mesh(); 10 11 tmp&lt;fvMatrix&lt;Type&gt;&gt; tfvm 12 ( 13 new fvMatrix&lt;Type&gt; 14 ( 15 vf, 16 dimVol*su.dimensions() 17 ) 18 ); 19 fvMatrix&lt;Type&gt;&amp; fvm = tfvm.ref(); 20 21 fvm.source() -= mesh.V()*su.field(); 22 23 return tfvm; 24 } Snippet #1: The explicit source term function Su() in OpenFOAM Implicit Treatment Sp() The next one to explore is the Implicit treatment through the Sp() function in OpenFOAM. Snippet #2 shows how the Sp() is implemented. Looking at line 21 of Snippet #2, one can see that sp.field() (the first argument in the function, i.e. \\(\\Phi\\)) is added to the fvm.diag() matrix which is the diagonal part of \\([A]\\) in equation (7). This confirms that Sp() is implemented in agreement with the theory. Another important difference between Su() and Sp()is the returned unit which the difference can be seen in line 16 of both Snippet #1 and #2. The reasoning can be seen in (4) and (7) where Sc is constant and Sp is multiplied by the dependent variable. So, this is reflected by multiplying the unit of the solved variable (the second argument in the functions, i.e. \\(x\\)) through vf.dimensions() in line 16 of the Snippets. 1 template&lt;class Type&gt; 2 Foam::tmp&lt;Foam::fvMatrix&lt;Type&gt;&gt; 3 Foam::fvm::Sp 4 ( 5 const volScalarField::Internal&amp; sp, 6 const GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; vf 7 ) 8 { 9 const fvMesh&amp; mesh = vf.mesh(); 10 11 tmp&lt;fvMatrix&lt;Type&gt;&gt; tfvm 12 ( 13 new fvMatrix&lt;Type&gt; 14 ( 15 vf, 16 dimVol*sp.dimensions()*vf.dimensions() 17 ) 18 ); 19 fvMatrix&lt;Type&gt;&amp; fvm = tfvm.ref(); 20 21 fvm.diag() += mesh.V()*sp.field(); 22 23 return tfvm; 24 } Snippet #2: The explicit source term function Sp() in OpenFOAM Hybrid Treatment SuSp() The last one to explore is the Hybrid treatment through the SuSp() function in OpenFOAM. Snippet #3 shows how the SuSp() is implemented. Looking at lines 21 through 24 of Snippet #3, one can see that susp.field() (the first argument in the function, i.e. \\(\\Phi\\)) is either subtracted from fvm.source() matrix which is the \\([-b]\\) or added to the fvm.diag() matrix which is the diagonal part of \\([A]\\) in equation (7). This confirms that SuSp() is implemented in agreement with the theory. It would be useful to go through the selective logic in the code to understand how the code decides whether it is implicit or explicit. Let’s think of a positive susp.field() (the first argument in the function, i.e. \\(\\Phi\\)), first in line 21, the code compares it with scalar zero and selects the maximum. Since it’s positive, the susp.field() is selected and multiplied by the volume and added to the diagonal coefficient matrix. It continues to line 23, and compares a positive susp.field() with a scalar zero to select the minimum. Of course, zero is selected and then multiplied by volume. Therefore no changes are done to the source matrix. The reverse can also be thought for a negative susp.field(). This time zero is selected for the diagonal matrix hence no changes are made to it however a negative susp.field() is selected for the source matrix, multiplied with the dependent variable and subtracted from itself. So, in short, it can be said that if the first argument of the SuSp() function is positive the function directly changes the diagonals of the coefficient matrix, and if it is negative then it is multiplied with the independent variable, and changes the source coefficients. 1 template&lt;class Type&gt; 2 Foam::tmp&lt;Foam::fvMatrix&lt;Type&gt;&gt; 3 Foam::fvm::SuSp 4 ( 5 const volScalarField::Internal&amp; susp, 6 const GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; vf 7 ) 8 { 9 const fvMesh&amp; mesh = vf.mesh(); 10 11 tmp&lt;fvMatrix&lt;Type&gt;&gt; tfvm 12 ( 13 new fvMatrix&lt;Type&gt; 14 ( 15 vf, 16 dimVol*susp.dimensions()*vf.dimensions() 17 ) 18 ); 19 fvMatrix&lt;Type&gt;&amp; fvm = tfvm.ref(); 20 21 fvm.diag() += mesh.V()*max(susp.field(), scalar(0)); 22 23 fvm.source() -= mesh.V()*min(susp.field(), scalar(0)) 24 *vf.primitiveField(); 25 26 return tfvm; 27 } Snippet #3: The hybrid source term function SuSp() in OpenFOAM References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
