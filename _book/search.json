[{"path":"index.html","id":"preface","chapter":"Preface","heading":"Preface","text":"landing page.","code":""},{"path":"literature-review.html","id":"literature-review","chapter":"Literature Review","heading":"Literature Review","text":"Deneme","code":""},{"path":"source-term-treatment.html","id":"source-term-treatment","chapter":"Source Term Treatment","heading":"Source Term Treatment","text":"partial differential equations converted sets algebraic equations equation discretization usually form equation (1) \\([]\\) sparse coefficient matrix, \\([x]\\) unknown column vector, \\([b]\\) source vector. coefficients algebraic equations stored \\([]\\) matrix fvMatrix template class discretization.\\[\\begin{equation}\n  [][x]=[b]\n  \\tag{1}\n\\end{equation}\\]Source terms can specified Explicit, Implicit, Implicit/Explicit (Hybrid hereinafter) Su(), Sp(), SuSp() functions, respectively, OpenFOAM. functions handle incorporation source terms coefficient matrices source term vectors. Explicit treatment Su() alters coefficients source vector (.e. \\([b]\\)) Implicit treatment Sp() modifies diagonal coefficients coefficient matrix (.e. \\([]\\)). Hybrid treatment automatically selects Implicit Explicit treatment depending sign coefficients. Implicit treatment selected coefficients greater zero Explicit treatment selected coefficients less zero. Though sounds arbitrary, good reason behind perhaps can best explained example.Let’s look steady one-dimensional heat conduction example given [1] given equation (2) \\(k\\) thermal conductivity, \\(T\\) temperature, \\(S\\) rate heat generation per unit volume.\\[\\begin{equation}\n\\frac{d}{d x}\\left(k \\frac{d T}{d x}\\right)+S=0\n\\tag{2}\n\\end{equation}\\]discretization equation (2) can done utilizing widely used grid-point notation P central node, E W neighbors. notation can found [1].\\[\\begin{equation}\n\\begin{aligned}\n\\left(k \\frac{d T}{d x}\\right)_e-\\left(k \\frac{d T}{d x}\\right)_w+\\int_w^e S d x &=0 \\\\\n\\frac{k_e\\left(T_E-T_P\\right)}{(\\delta x)_e}-\\frac{k_w\\left(T_P-T_W\\right)}{(\\delta x)_w}+\\bar{S} \\Delta x &=0 \\\\\n\\end{aligned}\n\\tag{3}\n\\end{equation}\\];\\[\\begin{equation}\n\\bar{S}=S_C+S_P T_P\n\\tag{4}\n\\end{equation}\\]\\(\\bar{S}\\) average value source therm control volume consisted constant \\(S_C\\) coefficient \\(S_P\\) dependent variable \\(T_P\\). can seen \\(\\bar{S}\\) constructed linear source discussed detail later. discretized equation (3) can now written general format shown equation (5).\\[\\begin{equation}\na_P T_P=a_E T_E+a_W T_W+b\n\\tag{5}\n\\end{equation}\\];\\[\\begin{equation}\n\\begin{aligned}\na_E &=\\frac{k_e}{(\\delta x)_e} \\\\\na_W &=\\frac{k_w}{(\\delta x)_w} \\\\\na_P &=a_E+a_W - S_P\\Delta x \\\\\nb &=S_C\\Delta x\n\\end{aligned}\n\\tag{6}\n\\end{equation}\\]known practical applications, source dependent independent dependent variable (.e. \\(T\\)) algebraic equation. reason source defined equation (4). discretized equations linear, source term can also linear dependence. However, sources nonlinear certain applications. Therefore, linearization must done able incorporate source terms discretized equations. done iterative procedures splitting \\(S_C\\) \\(S_P\\) parts intuitive way. However, details discussed . trying understand source term incorporated diagonal coefficient matrix source vector. reasoning lay equation (6).[1], four basic rules laid best represent physics proposed procedure. Rule number 2 requires positive coefficients meaning neighbors center-point coefficients must sign. Rule number 3 source term linearization. According rule, negative slope linearization accepted. acceptance criterion \\(S_P\\) equation (4) must always negative equal zero source term linearized. reasoning can seen equation (6) \\(- S_P\\Delta x\\) added \\(a_P\\) constructs diagonal terms matrix equation. Considering diagonal dominance, basically demands positive (rule number 2) large \\(a_P\\), possible get negative values \\(S_P\\) positive. Therefore, order ensure positive (large) diagonal coefficients, \\(S_P\\) must negative equal zero. constant part (\\(S_C\\)) source, can seen \\(b\\) equation (6) added source directly .Considering explanation, now source term treatment OpenFOAM can explained . Due matrix operations OpenFOAM, equation (1) fact constructed shown equation (7) sending source term left-hand side (LHS). useful later individual source treatment functions introduced.\\[\\begin{equation}\n[][x] + [-b] = 0\n\\tag{7}\n\\end{equation}\\]now possible investigate coded source term treatment functions; Su(), Sp(), SuSp() detail. source codes header files functions can found ~\\src\\finiteVolume\\finiteVolume\\fvm directory names fvmSup.C fvmSup.H. noted functions can utilized finiteVolumeMethod (fvm::) finiteVolumeCalculus (fvc::) static functions however explanation based fvm:: one. functions use two arguments, instance, Su(\\(\\Phi\\),\\(x\\)). first argument \\(\\Phi\\) field variable source term \\(x\\) dependent variable solved equation.Explicit Source Tem Treatment, Su()first one explore Explicit treatment Su() function OpenFOAM. Snippet #1 shows Su() implemented. Looking line 21 Snippet #1, one can see su.field() (first argument function, .e. \\(\\Phi\\)) subtracted fvm.source() matrix \\([-b]\\) equation (7). confirms Su() implemented agreement theory.Snippet #1: explicit source term function, Su(), OpenFOAM\\(\\space\\)Implicit Source Tem Treatment, Sp()next one explore Implicit treatment Sp() function OpenFOAM. Snippet #2 shows Sp() implemented. Looking line 21 Snippet #2, one can see sp.field() (first argument function, .e. \\(\\Phi\\)) added fvm.diag() matrix diagonal part \\([]\\) equation (7). confirms Sp() implemented agreement theory.Another important difference Su() Sp()returned unit difference can seen line 16 Snippet #1 #2. reasoning can seen (4) (7) Sc constant Sp multiplied dependent variable. , reflected multiplying unit solved variable (second argument functions, .e. \\(x\\)) vf.dimensions() line 16 Snippets.Snippet #2: explicit source term function, Sp(), OpenFOAM\\(\\space\\)Hybrid Source Tem Treatment, SuSp()last one explore Hybrid treatment SuSp() function OpenFOAM. Snippet #3 shows SuSp() implemented. Looking lines 21 24 Snippet #3, one can see susp.field() (first argument function, .e. \\(\\Phi\\)) either subtracted fvm.source() matrix \\([-b]\\) added fvm.diag() matrix diagonal part \\([]\\) equation (7). confirms SuSp() implemented agreement theory.useful go selective logic code understand code decides whether implicit explicit. Let’s think positive susp.field() (first argument function, .e. \\(\\Phi\\)), first line 21, code compares scalar zero selects maximum. Since ’s positive, susp.field() selected multiplied volume added diagonal coefficient matrix. continues line 23, compares positive susp.field() scalar zero select minimum. course, zero selected multiplied volume. Therefore changes done source matrix. reverse can also thought negative susp.field(). time zero selected diagonal matrix hence changes made however negative susp.field() selected source matrix, multiplied dependent variable subtracted . , short, can said first argument SuSp() function positive function directly changes diagonals coefficient matrix, negative multiplied independent variable, changes source coefficients.Snippet #3: hybrid source term function, SuSp(), OpenFOAM","code":"1   template<class Type>\n2   Foam::tmp<Foam::fvMatrix<Type>>\n3   Foam::fvm::Su\n4   (\n5       const DimensionedField<Type, volMesh>& su,\n6       const GeometricField<Type, fvPatchField, volMesh>& vf\n7   )\n8   {\n9       const fvMesh& mesh = vf.mesh();\n10  \n11      tmp<fvMatrix<Type>> tfvm\n12      (\n13          new fvMatrix<Type>\n14          (\n15              vf,\n16              dimVol*su.dimensions()\n17          )\n18      );\n19      fvMatrix<Type>& fvm = tfvm.ref();\n20  \n21      fvm.source() -= mesh.V()*su.field();\n22  \n23      return tfvm;\n24     }1   template<class Type>\n2   Foam::tmp<Foam::fvMatrix<Type>>\n3   Foam::fvm::Sp\n4   (\n5       const volScalarField::Internal& sp,\n6       const GeometricField<Type, fvPatchField, volMesh>& vf\n7   )\n8   {\n9       const fvMesh& mesh = vf.mesh();\n10  \n11      tmp<fvMatrix<Type>> tfvm\n12      (\n13          new fvMatrix<Type>\n14          (\n15              vf,\n16              dimVol*sp.dimensions()*vf.dimensions()\n17          )\n18      );\n19      fvMatrix<Type>& fvm = tfvm.ref();\n20  \n21      fvm.diag() += mesh.V()*sp.field();\n22  \n23      return tfvm;\n24  }1   template<class Type>\n2   Foam::tmp<Foam::fvMatrix<Type>>\n3   Foam::fvm::SuSp\n4   (\n5       const volScalarField::Internal& susp,\n6       const GeometricField<Type, fvPatchField, volMesh>& vf\n7   )\n8   {\n9       const fvMesh& mesh = vf.mesh();\n10  \n11      tmp<fvMatrix<Type>> tfvm\n12      (\n13          new fvMatrix<Type>\n14          (\n15              vf,\n16              dimVol*susp.dimensions()*vf.dimensions()\n17          )\n18      );\n19      fvMatrix<Type>& fvm = tfvm.ref();\n20  \n21      fvm.diag() += mesh.V()*max(susp.field(), scalar(0));\n22  \n23      fvm.source() -= mesh.V()*min(susp.field(), scalar(0))\n24          *vf.primitiveField();\n25  \n26      return tfvm;\n27  }"},{"path":"references.html","id":"references","chapter":"References","heading":"References","text":"","code":""}]
